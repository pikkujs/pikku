import { pikkuSessionlessFunc } from '../../../../.pikku/pikku-types.gen.js'
import { getFileImportRelativePath } from '../../../utils/file-import-path.js'
import { getPikkuFilesAndMethods } from '../../../utils/pikku-files-and-methods.js'
import { writeFileInDir } from '../../../utils/file-writer.js'
import { logCommandInfoAndTime } from '../../../middleware/log-command-info-and-time.js'

export const serializeServicesMap = (
  functionsMetaData: Record<string, any>,
  middlewareServices: string[] = [],
  servicesImport: string,
  sessionServicesImport: string
): string => {
  // Extract all unique services from all functions
  const usedServices = new Set<string>()

  // Internal services that are created internally and not via the create service script
  const internalServices = new Set(['rpc', 'mcp', 'channel', 'userSession'])

  for (const funcMeta of Object.values(functionsMetaData)) {
    if (funcMeta.services && Array.isArray(funcMeta.services.services)) {
      funcMeta.services.services.forEach((service: string) => {
        // Only include services that are not internal
        if (!internalServices.has(service)) {
          usedServices.add(service)
        }
      })
    }
  }

  // Add middleware services that might not be detected from function inspection
  middlewareServices.forEach((service) => {
    if (!internalServices.has(service)) {
      usedServices.add(service)
    }
  })

  // Create a map of services with true for all needed services
  const servicesMap = Object.fromEntries(
    Array.from(usedServices)
      .sort()
      .map((service) => [service, true])
  )

  // Generate the TypeScript code
  const serviceKeys = Object.keys(servicesMap).sort()

  // Services that are always required internally by the framework
  const defaultServices = ['config', 'logger', 'variables', 'schema']

  // Combine default services with detected services
  const allRequiredServices = [
    ...new Set([...defaultServices, ...serviceKeys]),
  ].sort()

  // For RequiredSingletonServices, we need to pick from the actual SingletonServices interface
  // This will be resolved at compile time based on what's actually in the SingletonServices interface
  // We don't need to hardcode which services are singletons beyond the core framework ones

  const code = [
    '/**',
    ' * This file was generated by the @pikku/cli',
    ' */',
    '',
    servicesImport,
    sessionServicesImport,
    "import type { PikkuInteraction } from '@pikku/core'",
    '',
    'export const singletonServices = {',
    ...Object.keys(servicesMap).map((service) => `    '${service}': true,`),
    '} as const',
    '',
    '// Singleton services (created once at startup)',
    '// Only includes services that are both required and available in SingletonServices',
    `export type RequiredSingletonServices = Pick<SingletonServices, Extract<keyof SingletonServices, ${allRequiredServices.map((key) => `'${key}'`).join(' | ')}>> & Partial<Omit<SingletonServices, ${allRequiredServices.map((key) => `'${key}'`).join(' | ')}>>`,
    '',
    '// Session services (created per request, can access singleton services)',
    '// Omits singleton services and PikkuInteraction (mcp, rpc, http, channel)',
    `export type RequiredSessionServices = Omit<Services, keyof SingletonServices | keyof PikkuInteraction>`,
    '',
  ].join('\n')

  return code
}

export const pikkuServices: any = pikkuSessionlessFunc<void, void>({
  func: async ({ logger, cliConfig, getInspectorState }) => {
    const visitState = await getInspectorState()

    const { sessionServicesType, singletonServicesType } =
      await getPikkuFilesAndMethods(
        logger,
        visitState,
        cliConfig.packageMappings,
        cliConfig.typesDeclarationFile,
        {},
        {
          sessionServiceType: true,
          singletonServicesType: true,
        }
      )

    const servicesImport = `import type { ${singletonServicesType.type} } from '${getFileImportRelativePath(cliConfig.typesDeclarationFile, singletonServicesType.typePath, cliConfig.packageMappings)}'`
    const sessionServicesImport = `import type { ${sessionServicesType.type} } from '${getFileImportRelativePath(cliConfig.typesDeclarationFile, sessionServicesType.typePath, cliConfig.packageMappings)}'`

    const servicesCode = serializeServicesMap(
      visitState.functions.meta,
      cliConfig.middlewareServices,
      servicesImport,
      sessionServicesImport
    )
    await writeFileInDir(logger, cliConfig.servicesFile, servicesCode)
  },
  middleware: [
    logCommandInfoAndTime({
      commandStart: 'Generating Pikku services map',
      commandEnd: 'Generated Pikku services map',
      skipCondition: async ({ getInspectorState }) => {
        const visitState = await getInspectorState()
        return visitState.functions.files.size === 0
      },
      skipMessage: '',
    }),
  ],
})
