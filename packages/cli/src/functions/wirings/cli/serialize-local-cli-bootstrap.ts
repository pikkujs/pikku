import { getFileImportRelativePath } from '../../../utils/file-import-path.js'
import { Config } from '../../../../types/application-types.js'

/**
 * Serializes the local (in-program) CLI bootstrap code
 */
export function serializeLocalCLIBootstrap(
  programName: string,
  _programMeta: any,
  bootstrapFile: string,
  config: Config,
  pikkuConfigFactory: { file: string; variable: string },
  singletonServicesFactory: { file: string; variable: string },
  sessionServicesFactory: { file: string; variable: string }
): string {
  const capitalizedName =
    programName.charAt(0).toUpperCase() + programName.slice(1).replace(/-/g, '')

  // Get relative import paths
  const pikkuConfigPath = getFileImportRelativePath(
    bootstrapFile,
    pikkuConfigFactory.file,
    config.packageMappings
  )
  const singletonServicesPath = getFileImportRelativePath(
    bootstrapFile,
    singletonServicesFactory.file,
    config.packageMappings
  )
  const sessionServicesPath = getFileImportRelativePath(
    bootstrapFile,
    sessionServicesFactory.file,
    config.packageMappings
  )
  const cliBootstrapPath = getFileImportRelativePath(
    bootstrapFile,
    config.bootstrapFiles.cli,
    config.packageMappings
  )

  return `/**
 * This file was generated by the @pikku/cli
 */
import { parseCLIArguments, runCLICommand, pikkuState } from '@pikku/core'
import { LocalVariablesService } from '@pikku/core/services'
import { ${pikkuConfigFactory.variable} as createConfig } from '${pikkuConfigPath}'
import { ${singletonServicesFactory.variable} as createSingletonServices } from '${singletonServicesPath}'
import { ${sessionServicesFactory.variable} as createSessionServices } from '${sessionServicesPath}'
import '${cliBootstrapPath}'

/**
 * ${capitalizedName} CLI function
 * Handles command line arguments and executes the appropriate function
 */
export async function ${capitalizedName}CLI(args: string[] = process.argv.slice(2)): Promise<void> {
  try {
    // Get CLI metadata from state
    const allCLIMeta = pikkuState('cli', 'meta') || {}
    const programMeta = allCLIMeta['${programName}']

    if (!programMeta) {
      console.error('Error: CLI program "${programName}" not found')
      process.exit(1)
    }

    // Parse arguments for this specific program
    const parsed = parseCLIArguments(args, '${programName}', allCLIMeta)

    // Handle help (check after parsing to support subcommand help)
    if (args.includes('--help') || args.includes('-h') || args.length === 0) {
      showHelp(programMeta, parsed.commandPath, allCLIMeta)
      return
    }

    if (parsed.errors.length > 0) {
      console.error('Errors:')
      parsed.errors.forEach(error => console.error(\`  \${error}\`))
      process.exit(1)
    }

    // Merge positionals and options into single data object
    const data = { ...parsed.positionals, ...parsed.options }

    // Create config (pass data in case it needs to use any parsed options)
    const config = await createConfig(new LocalVariablesService(), data as any)

    // Create services with config
    const singletonServices = await createSingletonServices(config)

    // Execute the command
    await runCLICommand({
      program: '${programName}',
      commandPath: parsed.commandPath,
      data,
      singletonServices,
      createSessionServices: createSessionServices as any,
    })

  } catch (error: any) {
    console.error('Error:', error)

    // Show stack trace in verbose mode
    if (args.includes('--verbose') || args.includes('-v')) {
      console.error('Stack trace:', error.stack)
    }

    process.exit(1)
  }
}

/**
 * Show help for the CLI program or a specific command
 */
function showHelp(programMeta: any, commandPath: string[] = [], allCLIMeta: any = {}): void {
  // If no command path, show top-level help
  if (commandPath.length === 0) {
    console.log(\`Usage: ${programName} [options] <command>\`)
    console.log()

    if (programMeta.description) {
      console.log(programMeta.description)
      console.log()
    }

    // Show global options
    console.log('Options:')
    console.log('  -h, --help  Show help information')
    if (programMeta.options && Object.keys(programMeta.options).length > 0) {
      for (const [name, option] of Object.entries(programMeta.options)) {
        const opt = option as any
        const short = opt.short ? \`-\${opt.short}, \` : ''
        const defaultVal = opt.default !== undefined ? \` (default: \${opt.default})\` : ''
        console.log(\`  \${short}--\${name}  \${opt.description || ''}\${defaultVal}\`)
      }
    }
    console.log()

    // Show commands
    if (programMeta.commands && Object.keys(programMeta.commands).length > 0) {
      console.log('Commands:')
      showCommandsHelp(programMeta.commands, '')
      console.log()
    }
    return
  }

  // Navigate to the specific command
  let currentCommand = programMeta.commands[commandPath[0]]
  let commandPathStr = commandPath[0]

  if (!currentCommand) {
    console.error(\`Command not found: \${commandPath.join(' ')}\`)
    return
  }

  for (let i = 1; i < commandPath.length; i++) {
    if (!currentCommand.subcommands || !currentCommand.subcommands[commandPath[i]]) {
      console.error(\`Command not found: \${commandPath.join(' ')}\`)
      return
    }
    currentCommand = currentCommand.subcommands[commandPath[i]]
    commandPathStr = commandPath.slice(0, i + 1).join(' ')
  }

  // Show help for this specific command
  if (currentCommand.command) {
    // This is a leaf command
    console.log(\`Usage: ${programName} \${commandPathStr} [options]\`)
    console.log()

    if (currentCommand.description) {
      console.log(currentCommand.description)
      console.log()
    }

    // Collect all inherited options (global + command-specific)
    const allOptions: Record<string, any> = { ...programMeta.options }

    // Navigate through command path to collect inherited options
    let navCommand = programMeta.commands[commandPath[0]]
    for (let i = 0; i < commandPath.length - 1; i++) {
      if (navCommand.options) {
        Object.assign(allOptions, navCommand.options)
      }
      if (navCommand.subcommands) {
        navCommand = navCommand.subcommands[commandPath[i + 1]]
      }
    }

    // Add current command options
    if (currentCommand.options) {
      Object.assign(allOptions, currentCommand.options)
    }

    // Show all options (inherited + command-specific)
    console.log('Options:')
    console.log('  -h, --help  Show help information')
    if (Object.keys(allOptions).length > 0) {
      for (const [name, option] of Object.entries(allOptions)) {
        const opt = option as any
        const short = opt.short ? \`-\${opt.short}, \` : ''
        const defaultVal = opt.default !== undefined ? \` (default: \${opt.default})\` : ''
        console.log(\`  \${short}--\${name}  \${opt.description || ''}\${defaultVal}\`)
      }
    }
    console.log()

    // Show positionals if any
    if (currentCommand.positionals && currentCommand.positionals.length > 0) {
      console.log('Arguments:')
      for (const positional of currentCommand.positionals) {
        const required = positional.required ? '(required)' : '(optional)'
        const variadic = positional.variadic ? '...' : ''
        console.log(\`  \${positional.name}\${variadic} \${required}\`)
      }
      console.log()
    }
  } else if (currentCommand.subcommands) {
    // This is a command group
    console.log(\`Usage: ${programName} \${commandPathStr} <command>\`)
    console.log()

    if (currentCommand.description) {
      console.log(currentCommand.description)
      console.log()
    }

    console.log('Options:')
    console.log('  -h, --help  Show help information')
    console.log()

    // Show subcommands
    console.log('Commands:')
    showCommandsHelp(currentCommand.subcommands, '')
    console.log()
  }
}

/**
 * Recursively show commands help
 */
function showCommandsHelp(commands: any, prefix: string): void {
  for (const [name, command] of Object.entries(commands)) {
    const cmd = command as any
    const fullName = prefix ? \`\${prefix} \${name}\` : name

    if (cmd.command) {
      // Leaf command
      console.log(\`  \${fullName.padEnd(20)} \${cmd.description || ''}\`)
    } else if (cmd.subcommands) {
      // Command group
      console.log(\`  \${fullName.padEnd(20)} \${cmd.description || ''}\`)
      showCommandsHelp(cmd.subcommands, fullName)
    }
  }
}

// Export as default for easy importing
export default ${capitalizedName}CLI

// For direct execution (if this file is run directly)
if (import.meta.url === \`file://\${process.argv[1]}\`) {
  ${capitalizedName}CLI().catch(error => {
    console.error('Fatal error:', error.message)
    process.exit(1)
  })
}
`
}
