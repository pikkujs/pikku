---
name: pikku-kysely
description: Best practices for using Kysely with PostgreSQL in Pikku applications. Use when writing database queries, handling conflicts, joins, transactions, or any database operations.
---

# Pikku Kysely Skill

This skill provides best practices for using Kysely with PostgreSQL in Pikku applications, focusing on efficient conflict resolution, proper type safety, and optimal database operations.

## When to use this skill

- Writing Kysely database queries
- Implementing upsert operations
- Handling database conflicts and constraints
- Creating complex joins with proper typing
- Writing transactional operations
- Optimizing database queries
- Performing bulk operations

## ⚠️ CRITICAL RULES

### 1. Always Use camelCase

**Kysely automatically converts snake_case database columns to camelCase in TypeScript. You must NEVER use snake_case in your TypeScript code - only camelCase.**

✅ **Correct:**

```typescript
const user = await kysely
  .selectFrom('user')
  .select(['userId', 'createdAt', 'displayName'])
  .where('userId', '=', id)
  .executeTakeFirst()
```

❌ **Wrong:**

```typescript
const user = await kysely
  .selectFrom('user')
  .select(['user_id', 'created_at', 'display_name']) // DON'T use snake_case!
  .where('user_id', '=', id)
  .executeTakeFirst()
```

### 2. Always Import Database Types Directly

**Always import database entity types directly from the generated database types. NEVER re-export them through application-types.d.ts.**

✅ **Correct:**

```typescript
import type {
  Order,
  Ingredient,
  Dish,
} from '@pikku-workspace-starter/sdk/.generated/database-types-pure.js'
```

❌ **Wrong:**

```typescript
import type { Order, Ingredient, Dish } from '../../application-types.d.js' // DON'T re-export!
```

**Application types that don't come from the database (DTOs, input/output types) should live in `function-types.ts`.**

### Type Organization in Yarn Workspaces with SDK Package

**When using a yarn workspace with an SDK package, ALL types should live in the SDK package and be imported from there:**

✅ **Correct structure:**

```
workspace/
├── packages/
│   ├── sdk/
│   │   ├── .generated/
│   │   │   └── database-types-pure.js    # Generated by kysely-codegen
│   │   ├── src/
│   │   │   ├── application-types.ts      # Application types (UserSession, etc.)
│   │   │   └── function-types.ts         # DTOs, input/output types
│   │   └── package.json
│   └── functions/
│       └── src/
│           └── functions/
│               └── user.functions.ts     # Import types from @workspace/sdk
```

✅ **Import all types from SDK:**

```typescript
// In packages/functions/src/functions/user.functions.ts
import type { User } from '@pikku-workspace-starter/sdk/.generated/database-types-pure.js'
import type { UserSession } from '@pikku-workspace-starter/sdk/application-types.js'
import type { LoginResponse } from '@pikku-workspace-starter/sdk/function-types.js'
```

❌ **Wrong - types in functions package:**

```typescript
// DON'T define UserSession in packages/functions/src/application-types.d.ts
export interface UserSession {
  userId: string
  name: string
}
```

**Why this matters:**

- Pikku type generation requires types to be in the SDK package for proper RPC map generation
- Frontend and backend can share types from a single source of truth
- Type changes propagate correctly across the workspace
- Prevents "Type X not found in typesMap" errors during `pikku prebuild`

### 3. Typing Joined Queries with Related Data

**When returning data from joined queries, use the pattern `BaseType & { related: Pick<RelatedType, 'field1' | 'field2'> }` to properly type the result.**

Use `jsonBuildObject` from `kysely/helpers/postgres` for efficient joins:

```typescript
import { jsonBuildObject } from 'kysely/helpers/postgres'

type OrderWithClient = Order & {
  client: Pick<User, 'name' | 'role'>
}

export const getPendingOrders = pikkuFunc<void, OrderWithClient[]>({
  func: async ({ kysely }) => {
    return await kysely
      .selectFrom('order')
      .innerJoin('user as client', 'client.userId', 'order.clientId')
      .selectAll('order')
      .select((eb) =>
        jsonBuildObject({
          name: eb.ref('client.name'),
          role: eb.ref('client.role'),
        }).as('client')
      )
      .where('order.status', '=', 'pending')
      .execute()
  },
})
```

### 4. Use Lateral Joins for Complex Relationships

**Always use `jsonBuildObject` with lateral joins for efficient joined queries. This provides the best type safety and eliminates nullable field issues.**

See [joined-queries.example.ts](examples/joined-queries.example.ts) for detailed patterns.

**Benefits:**

- Perfect TypeScript type inference - no nullable field issues
- Type-safe access to both base entity fields and related data
- Clear separation between the main entity and joined data
- More performant than client-side mapping
- Proper handling of optional vs required relationships

### 5. Use Single Query Patterns

**DO: Use single update with `.executeTakeFirstOrThrow()` instead of read-then-update**

✅ **Correct:**

```typescript
const updatedOrder = await kysely
  .updateTable('order')
  .set({ status: 'cancelled', updatedAt: new Date() })
  .where('orderId', '=', orderId)
  .returningAll()
  .executeTakeFirstOrThrow(() => new NotFoundError('Order not found'))
```

❌ **Wrong:**

```typescript
const order = await kysely
  .selectFrom('order')
  .select(['orderId'])
  .where('orderId', '=', orderId)
  .executeTakeFirst()

if (!order) throw new NotFoundError('Order not found')

await kysely
  .updateTable('order')
  .set({ status: 'cancelled' })
  .where('orderId', '=', orderId)
  .execute()
```

### 6. Use `.returningAll()` for Full Entities

```typescript
// ✅ Good
.returningAll()

// ❌ Avoid when you need all columns
.returning(['orderId', 'clientId', 'status', /* ... all fields */])
```

### 7. Delete Operations Return void

```typescript
// ✅ Good
export const deleteDish = pikkuFunc<{ dishId: string }, void>({
  func: async ({ kysely }, { dishId }) => {
    await kysely
      .deleteFrom('dish')
      .where('dishId', '=', dishId)
      .executeTakeFirstOrThrow(() => new NotFoundError('Dish not found'))
    // No return - either succeeds or throws
  },
})

// ❌ Avoid
return { deleted: true } // Unnecessary - void is cleaner
```

## Core Principles

- **CRITICAL**: Always use camelCase in TypeScript types and Kysely queries
- **CRITICAL**: Always import database types directly from generated files
- Use PostgreSQL's native `ON CONFLICT` functionality instead of manual conflict detection
- Leverage Kysely's type-safe query building
- Prefer atomic database operations over application-level logic
- Use transactions for multi-table operations that must succeed or fail together
- Use single-query patterns with `.executeTakeFirstOrThrow()`

## Key Patterns

### Conflict Resolution with ON CONFLICT

Use `ON CONFLICT` for upsert operations instead of checking if a record exists:

See [upsert-operations.example.ts](examples/upsert-operations.example.ts) for detailed examples of:

- DO NOTHING (ignore conflicts)
- DO UPDATE SET (upsert)
- Conditional updates with WHERE

### Atomic Operations

Use database-level atomic operations for increment/decrement:

See [atomic-operations.example.ts](examples/atomic-operations.example.ts) for patterns on:

- Atomic increment/decrement
- Avoiding read-modify-write race conditions

### Bulk Operations

Efficiently handle multiple records in single queries:

See [bulk-operations.example.ts](examples/bulk-operations.example.ts) for:

- Bulk insert with conflict resolution
- Bulk updates with CTE

### Transactions

Multi-table operations that must succeed or fail together:

See [transactions.example.ts](examples/transactions.example.ts) for:

- Transaction patterns
- Error handling in transactions
- Stock management examples

### Query Optimization

See [query-optimization.example.ts](examples/query-optimization.example.ts) for:

- Using indexes effectively
- Efficient joins and aggregations
- Single query optimizations

## Common Anti-patterns to Avoid

❌ **Don't use application-level locks:**

```typescript
let isProcessing = false // Use database constraints instead
```

❌ **Don't chain dependent queries unnecessarily:**

```typescript
// Use JOINs or subqueries instead
const orders = await kysely.selectFrom('order').selectAll().execute()
for (const order of orders) {
  const items = await kysely.selectFrom('orderItem')...  // N+1 query problem
}
```

❌ **Don't ignore unique constraint violations:**

```typescript
try {
  await kysely.insertInto('ingredient').values(data).execute()
} catch {
  // Silent failure - bad! Handle explicitly
}
```

❌ **Don't use snake_case in TypeScript:**

```typescript
.select(['user_id', 'created_at'])  // NEVER do this!
```

❌ **Don't re-export database types:**

```typescript
// application-types.d.ts
export type { Order, User } from '@pikku-workspace-starter/sdk' // DON'T!
```

## Error Handling

Handle database constraints and map to appropriate `PikkuError` types:

```typescript
try {
  const dish = await kysely
    .insertInto('dish')
    .values({ name, description, price })
    .returningAll()
    .executeTakeFirstOrThrow()

  return dish
} catch (error) {
  if (error instanceof Error && error.message.includes('duplicate key')) {
    throw new ConflictError('Dish with this name already exists')
  }
  throw error
}
```

## PR/CI Checklist

- [ ] **CRITICAL**: All TypeScript types and Kysely queries use camelCase (not snake_case)
- [ ] **CRITICAL**: All HTTP route parameters use camelCase (e.g., `:orderId` not `:order_id`)
- [ ] **CRITICAL**: Database types imported directly from generated files (not through re-exports)
- [ ] **CRITICAL**: Non-database types (DTOs) live in `function-types.ts`
- [ ] **CRITICAL**: Joined queries use proper typing pattern: `BaseType & { related: Pick<RelatedType, 'field1' | 'field2'> }`
- [ ] Use `ON CONFLICT` instead of manual existence checks
- [ ] Atomic operations for increment/decrement operations
- [ ] Bulk operations for multiple records
- [ ] Proper transaction usage for multi-table operations
- [ ] Efficient JOINs instead of N+1 queries
- [ ] Database constraint errors caught and mapped to `PikkuError`s
- [ ] No application-level locks or race-prone read-modify-write patterns
- [ ] Query performance considerations (indexes, ordering, limits)
- [ ] Use `.returningAll()` instead of manually listing columns
- [ ] Use `.executeTakeFirstOrThrow()` for single record operations
- [ ] Delete operations return `void` and use `.executeTakeFirstOrThrow()`
