import {
  getFileImportRelativePath,
  getPikkuFilesAndMethods,
  logCommandInfoAndTime,
  writeFileInDir,
} from '../../utils.js'
import { PikkuCommand } from '../../types.js'
import { PikkuCLIConfig } from '../../pikku-cli-config.js'
import { InspectorState } from '@pikku/inspector'

export const serializeServicesMap = (
  functionsMetaData: Record<string, any>,
  middlewareServices: string[] = [],
  servicesImport: string,
  sessionServicesImport: string
): string => {
  // Extract all unique services from all functions
  const usedServices = new Set<string>()

  // Internal services that are created internally and not via the create service script
  const internalServices = new Set(['rpc', 'mcp', 'channel', 'userSession'])

  for (const funcMeta of Object.values(functionsMetaData)) {
    if (funcMeta.services && Array.isArray(funcMeta.services.services)) {
      funcMeta.services.services.forEach((service: string) => {
        // Only include services that are not internal
        if (!internalServices.has(service)) {
          usedServices.add(service)
        }
      })
    }
  }

  // Add middleware services that might not be detected from function inspection
  middlewareServices.forEach((service) => {
    if (!internalServices.has(service)) {
      usedServices.add(service)
    }
  })

  // Create a map of services with true for all needed services
  const servicesMap = Object.fromEntries(
    Array.from(usedServices)
      .sort()
      .map((service) => [service, true])
  )

  // Generate the TypeScript code
  const serviceKeys = Object.keys(servicesMap).sort()

  // Services that are always required internally by the framework
  const defaultServices = ['config', 'logger', 'variables', 'schema']

  // Combine default services with detected services
  const allRequiredServices = [
    ...new Set([...defaultServices, ...serviceKeys]),
  ].sort()

  // For RequiredSingletonServices, we need to pick from the actual SingletonServices interface
  // This will be resolved at compile time based on what's actually in the SingletonServices interface
  // We don't need to hardcode which services are singletons beyond the core framework ones

  const code = [
    '/**',
    ' * This file was generated by the @pikku/cli',
    ' */',
    '',
    servicesImport,
    sessionServicesImport,
    "import type { PikkuInteraction } from '@pikku/core'",
    '',
    'export const singletonServices = {',
    ...Object.keys(servicesMap).map((service) => `    '${service}': true,`),
    '} as const',
    '',
    '// Singleton services (created once at startup)',
    '// Only includes services that are both required and available in SingletonServices',
    `export type RequiredSingletonServices = Pick<SingletonServices, Extract<keyof SingletonServices, ${allRequiredServices.map((key) => `'${key}'`).join(' | ')}>> & Partial<Omit<SingletonServices, ${allRequiredServices.map((key) => `'${key}'`).join(' | ')}>>`,
    '',
    '// Session services (created per request, can access singleton services)',
    '// Omits singleton services and PikkuInteraction (mcp, rpc, http, channel)',
    `export type RequiredSessionServices = Omit<Services, keyof SingletonServices | keyof PikkuInteraction>`,
    '',
  ].join('\n')

  return code
}

export const pikkuServices: PikkuCommand = async (
  logger,
  cliConfig: PikkuCLIConfig,
  visitState: InspectorState
) => {
  return await logCommandInfoAndTime(
    logger,
    'Generating Pikku services map',
    'Generated Pikku services map',
    [visitState.functions.files.size === 0],
    async () => {
      const { sessionServicesType, singletonServicesType } =
        await getPikkuFilesAndMethods(
          logger,
          visitState,
          cliConfig.packageMappings,
          cliConfig.typesDeclarationFile,
          {},
          {
            sessionServiceType: true,
            singletonServicesType: true,
          }
        )

      const servicesImport = `import type { ${singletonServicesType.type} } from '${getFileImportRelativePath(cliConfig.typesDeclarationFile, singletonServicesType.typePath, cliConfig.packageMappings)}'`
      const sessionServicesImport = `import type { ${sessionServicesType.type} } from '${getFileImportRelativePath(cliConfig.typesDeclarationFile, sessionServicesType.typePath, cliConfig.packageMappings)}'`

      const servicesCode = serializeServicesMap(
        visitState.functions.meta,
        cliConfig.middlewareServices,
        servicesImport,
        sessionServicesImport
      )
      await writeFileInDir(logger, cliConfig.servicesFile, servicesCode)
    }
  )
}
