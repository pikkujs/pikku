import type { workflowsMeta, WorkflowStepMeta } from '@pikku/core/workflow'

/**
 * Generate queue workers for workflow steps and orchestrator
 *
 * For each workflow, generates:
 * 1. RPC step workers (one per RPC form step)
 * 2. Orchestrator worker (one per workflow)
 *
 * Note: Queue metadata will be auto-generated by re-inspecting after this file is created
 */
export const serializeWorkflowWorkers = (workflowsMeta: workflowsMeta) => {
  const functionDefs: string[] = []
  const workers: string[] = []

  // Generate workers for each workflow
  for (const [workflowName, workflowMeta] of Object.entries(workflowsMeta)) {
    const { meta } = workflowMeta

    // Generate RPC step workers
    const rpcSteps = meta.steps.filter(
      (step): step is Extract<WorkflowStepMeta, { type: 'rpc' }> =>
        step.type === 'rpc' && step.stepName !== '<dynamic>'
    )

    for (const step of rpcSteps) {
      const queueName = `workflow-${workflowName}-${step.stepName}`
      // Convert to PascalCase: workflowName_stepName_worker -> WorkflowNameStepNameWorker
      const functionName = `${workflowName.charAt(0).toUpperCase() + workflowName.slice(1)}${step.stepName.charAt(0).toUpperCase() + step.stepName.slice(1)}Worker`
      const workerComment =
        step.description && step.description !== '<dynamic>'
          ? `// ${step.description}`
          : `// RPC step: ${step.stepName}`

      functionDefs.push(`
${workerComment}
export const ${functionName} = pikkuSessionlessFunc({
  name: '${functionName}',
  func: async (services, payload: any) => {
    const { runId, stepName, rpcName, data } = payload

    // Idempotency check - skip if already done
    const stepState = await services.workflowState.getStepState(runId, stepName)
    if (stepState.status === 'done') {
      return
    }

    try {
      // Execute RPC
      const result = await services.rpc.invoke(rpcName, data)

      // Store result
      await services.workflowState.setStepResult(runId, stepName, result)

      // Trigger orchestrator to continue workflow
      await services.workflowState.addToQueue('${workflowName}', runId)
    } catch (error: any) {
      // Store error
      await services.workflowState.setStepError(runId, stepName, error)

      // Mark workflow as failed
      await services.workflowState.updateRunStatus(runId, 'failed', undefined, {
        message: error.message,
        stack: error.stack,
        code: error.code,
      })

      throw error
    }
  }
})
`)

      workers.push(`
wireQueueWorker({
  queueName: '${queueName}',
  func: ${functionName} as any,
})
`)
    }

    // Generate orchestrator worker
    const orchestratorFunctionName = `${workflowName.charAt(0).toUpperCase() + workflowName.slice(1)}OrchestratorWorker`
    const orchestratorComment = workflowMeta.description
      ? `// Orchestrator for: ${workflowMeta.description}`
      : `// Orchestrator for ${workflowName} workflow`

    functionDefs.push(`
${orchestratorComment}
export const ${orchestratorFunctionName} = pikkuSessionlessFunc({
  name: '${orchestratorFunctionName}',
  func: async (services, payload: any) => {
    const { runId } = payload

    try {
      // Run workflow job (replays with caching)
      await runWorkflowJob(runId, services)
    } catch (error: any) {
      // WorkflowAsyncException is not an error - it means we scheduled a step
      if (error.name === 'WorkflowAsyncException') {
        // Workflow paused waiting for step completion
        return
      }

      // Real error - mark workflow as failed
      await services.workflowState!.updateRunStatus(runId, 'failed', undefined, {
        message: error.message,
        stack: error.stack,
        code: error.code,
      })

      throw error
    }
  }
})
`)

    workers.push(`
wireQueueWorker({
  queueName: 'workflow-${workflowName}-orchestrator',
  func: ${orchestratorFunctionName} as any,
})
`)
  }

  // Only include imports if there are workers
  const imports =
    workers.length > 0
      ? [
          "import { pikkuSessionlessFunc } from '../../.pikku/pikku-types.gen.js'",
          "import { wireQueueWorker } from '@pikku/core/queue'",
          "import { runWorkflowJob } from '@pikku/core/workflow'",
        ]
      : []

  return `/**
 * Auto-generated workflow queue workers
 *
 * This file contains:
 * - RPC step workers (one per RPC form step)
 * - Orchestrator workers (one per workflow)
 *
 * Do not edit manually - regenerate with 'npx pikku prebuild'
 */

${imports.join('\n')}

${functionDefs.join('\n')}

${workers.join('\n')}
`
}
