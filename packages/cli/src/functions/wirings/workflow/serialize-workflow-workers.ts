import type { WorkflowsMeta, WorkflowStepMeta } from '@pikku/core/workflow'

/**
 * Generate queue workers for workflow steps and orchestrator
 *
 * For each workflow, generates:
 * 1. RPC step workers (one per RPC form step)
 * 2. Orchestrator worker (one per workflow)
 *
 * Note: Queue metadata will be auto-generated by re-inspecting after this file is created
 */
export const serializeWorkflowWorkers = (workflowsMeta: WorkflowsMeta) => {
  const functionDefs: string[] = []
  const workers: string[] = []

  // Generate workers for each workflow
  for (const [workflowName, { steps, pikkuFuncName }] of Object.entries(workflowsMeta)) {

    // Generate orchestrator worker
    const orchestratorQueueName = `workflow-${workflowName}-orchestrator`
    const orchestratorFunctionName = `${workflowName.charAt(0).toUpperCase() + workflowName.slice(1)}OrchestratorWorker`

    // Generate RPC step workers
    const rpcSteps = steps.filter(
      (step): step is Extract<WorkflowStepMeta, { type: 'rpc' }> =>
        step.type === 'rpc' && step.stepName !== '<dynamic>'
    )

    for (const step of rpcSteps) {
      const queueName = `workflow-${workflowName}-${step.stepName}`
      const functionName = `${pikkuFuncName}Worker`

      functionDefs.push(`
export const ${functionName} = pikkuSessionlessFunc({
  func: async ({ workflowState, rpc }, payload: any) => {
    const { runId, stepName, rpcName, data } = payload

    // Idempotency check - skip if already done
    const stepState = await workflowState.getStepState(runId, stepName)
    if (stepState.status === 'done') {
      return
    }

    try {
      // Execute RPC
      const result = await rpc.invoke(rpcName, data)

      // Store result
      await workflowState.setStepResult(runId, stepName, result)

      // Trigger orchestrator to continue workflow
      await workflowState.addToQueue('${orchestratorQueueName}', runId)
    } catch (error: any) {
      // Store error
      await workflowState.setStepError(runId, stepName, error)

      // Mark workflow as failed
      await workflowState.updateRunStatus(runId, 'failed', undefined, {
        message: error.message,
        stack: error.stack,
        code: error.code,
      })

      throw error
    }
  }
})
`)

      workers.push(`
wireQueueWorker({
  queueName: '${queueName}',
  func: ${functionName} as any,
})
`)
    }

    functionDefs.push(`
export const ${orchestratorFunctionName} = pikkuSessionlessFunc({
  func: async ({ workflowState }, payload: any) => {
    const { runId } = payload

    if (!workflowState) {
      // TODO: Throw a better error message / typed
      throw new Error('WorkflowState service not available in orchestrator worker')
    }

    try {
      // Run workflow job (replays with caching)
      await workflowState.runWorkflowJob(runId)
    } catch (error: any) {
      // WorkflowAsyncException is not an error - it means we scheduled a step
      if (error.name === 'WorkflowAsyncException') {
        // Workflow paused waiting for step completion
        return
      }

      // Real error - mark workflow as failed
      await workflowState.updateRunStatus(runId, 'failed', undefined, {
        message: error.message,
        stack: error.stack,
        code: error.code,
      })

      throw error
    }
  }
})
`)

    workers.push(`
wireQueueWorker({
  queueName: '${orchestratorQueueName}',
  func: ${orchestratorFunctionName} as any,
})
`)
  }

  // Only include imports if there are workers
  const imports =
    workers.length > 0
      ? [
        "import { pikkuSessionlessFunc } from '../../.pikku/pikku-types.gen.js'",
        "import { wireQueueWorker } from '@pikku/core/queue'",
        "import { runWorkflowJob } from '@pikku/core/workflow'",
      ]
      : []

  return `/**
 * Auto-generated workflow queue workers
 *
 * This file contains:
 * - RPC step workers (one per RPC form step)
 * - Orchestrator workers (one per workflow)
 *
 * Do not edit manually - regenerate with 'npx pikku'
 */

${imports.join('\n')}

${functionDefs.join('\n')}

${workers.join('\n')}
`
}
